package org.iplantc.workflow.experiment;

import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import net.sf.json.JSON;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;

import org.iplantc.persistence.dto.step.TransformationStep;
import org.iplantc.persistence.dto.transformation.Transformation;
import org.iplantc.workflow.WorkflowException;
import org.iplantc.workflow.core.TransformationActivity;
import org.iplantc.workflow.dao.DaoFactory;
import org.iplantc.workflow.data.DataObject;
import org.iplantc.workflow.experiment.property.PropertyFormatter;
import org.iplantc.workflow.experiment.property.PropertyFormatterFactory;
import org.iplantc.workflow.model.Property;
import org.iplantc.workflow.model.PropertyGroup;
import org.iplantc.workflow.model.Template;

/**
 * The foundational API step formatter.
 * 
 * @author Dennis Roberts
 */
public class FapiStepFormatter {

    /**
     * The factory used to create data access objects.
     */
    private final DaoFactory daoFactory;

    /**
     * The type of step being formatted.
     */
    private final String stepType;

    /**
     * The name of the user who submitted the request.
     */
    private final String username;

    /**
     * The experiment that was submitted to the experiment runner service.
     */
    private final JSONObject experiment;

    /**
     * The analysis being formatted.
     */
    private final TransformationActivity analysis;

    /**
     * The step being formatted.
     */
    private final TransformationStep step;

    /**
     * A map of property names to property values.
     */
    private final Map<String, List<String>> propertyValues;

    /**
     * The path to the home directory in iRODS.
     */
    private final String irodsHome;

    /**
     * @param daoFactory the factory used to create data access objects.
     * @param stepType the type of step being formatted.
     * @param username the name of the user who submitted the request.
     * @param experiment the experiment configuration.
     * @param analysis the analysis that is currently being formatted.
     * @param step the step that is currently being formatted.
     * @param propertyValues a map of property names to property values.
     */
    public FapiStepFormatter(DaoFactory daoFactory, String stepType, String username, JSONObject experiment,
        TransformationActivity analysis, TransformationStep step, Map<String, List<String>> propertyValues,
        String irodsHome)
    {
        this.daoFactory = daoFactory;
        this.stepType = stepType;
        this.username = username;
        this.experiment = experiment;
        this.analysis = analysis;
        this.step = step;
        this.propertyValues = propertyValues;
        this.irodsHome = irodsHome;
    }

    /**
     * Formats the step.
     * 
     * @return the formatted step.
     */
    public JSONObject formatStep() {
        JSONObject formattedStep = new JSONObject();
        formattedStep.put("name", step.getName());
        formattedStep.put("type", stepType);
        addTemplateElements(formattedStep, getTemplateForStep(step));
        return formattedStep;
    }

    /**
     * Adds the elements containing information obtained from the template to the JSON object that represents the
     * formatted step.
     * 
     * @param formattedStep the formatted version of the step.
     * @param template the template.
     */
    private void addTemplateElements(JSONObject formattedStep, Template template) {
        if (template != null) {
            formattedStep.put("component", formatComponent(template.getComponent()));
            formattedStep.put("config", formatConfig(template));
        }
    }

    /**
     * Formats the step configuration for the given template.
     * 
     * @param template the template.
     * @return the step configuration.
     */
    private Object formatConfig(Template template) {
        JSONObject config = new JSONObject();
        config.put("input", new JSONArray());
        config.put("params", formatParameters(template));
        config.put("output", formatOutputs());
        return config;
    }

    /**
     * Formats the list of parameters for the given template.
     * 
     * @param template the template.
     * @return the list of parameters.
     */
    private JSONArray formatParameters(Template template) {
        JSONArray params = new JSONArray();
        addAutoGeneratedParams(params);
        addInputParams(params, template.getInputs());
        addParamsForPropertyGroups(params, template.getPropertyGroups());
        addOutputParams(params, template.getOutputs());
        return params;
    }

    /**
     * Adds automatically generated parameters to the list of parameters.
     * 
     * @param params the list of parameters.
     */
    protected void addAutoGeneratedParams(JSONArray params) {
        addCommandParam(params);
        addProxyUserParam(params);
        addJobNameParam(params);
        addArchiveParam(params);
        addArchivePathParam(params);
    }

    /**
     * Adds the parameter that tells the Foundational API where results should be archived.
     * 
     * @param params the list of parameters.
     */
    private void addArchivePathParam(JSONArray params) {
        String baseDir = experiment.getString("outputDirectory").replaceAll("^" + Pattern.quote(irodsHome), "");
        baseDir = baseDir.replaceAll("/$", "");
        String archivePath = baseDir + "/" + experiment.getString("name");
        params.add(generateParam(1, "--archivePath=", archivePath, "archivePath"));
    }

    /**
     * Adds the parameter that tells the Foundational API that results should be archived.
     * 
     * @param params the list of parameters.
     */
    private void addArchiveParam(JSONArray params) {
        params.add(generateParam(1, "--archive", "", "archiveResults"));
    }

    /**
     * Adds the job name parameter required by the Foundational API.
     * 
     * @param params the list of parameters.
     */
    private void addJobNameParam(JSONArray params) {
        params.add(generateParam(1, "--jobName=", experiment.getString("name"), "jobName"));
    }

    /**
     * Adds the proxy user parameter required by the Foundational API.
     * 
     * @param params the list of parameters.
     */
    private void addProxyUserParam(JSONArray params) {
        params.add(generateParam(1, "--proxy_user=", username, "proxyUser"));
    }

    /**
     * Adds the command parameter required by the Foundational API shim.
     * 
     * @param params the list of parameters.
     */
    private void addCommandParam(JSONArray params) {
        params.add(generateParam(0, "run", "", "command"));
    }

    /**
     * Generates a JSON object representing a parameter.
     * 
     * @param order the order specifier.
     * @param name the parameter name.
     * @param value the parameter value.
     * @param id the parameter id.
     * @return the JSON object.
     */
    private JSONObject generateParam(int order, String name, String value, String id) {
        JSONObject json = new JSONObject();
        json.put("order", order);
        json.put("name", "");
        json.put("value", name + value);
        json.put("id", id);
        return json;
    }

    /**
     * Adds parameters for file outputs.
     * 
     * @param params the list of parameters.
     * @param outputs the list of outputs.
     */
    private void addOutputParams(JSONArray params, List<DataObject> outputs) {
        FapiOutputParamFormatter formatter = new FapiOutputParamFormatter(step, propertyValues);
        for (DataObject output : outputs) {
            formatter.addParamsForOutput(params, output);
        }
    }

    /**
     * Adds parameters for file inputs.
     * 
     * @param params the list of parameters.
     * @param inputs the list of inputs.
     */
    private void addInputParams(JSONArray params, List<DataObject> inputs) {
        JSONObject config = experiment.getJSONObject("config");
        FapiInputParamFormatter formatter = new FapiInputParamFormatter(daoFactory, analysis, step, config,
            propertyValues);
        for (DataObject input : inputs) {
            formatter.addParamsForInput(params, input);
        }
    }

    /**
     * Adds a parameter for each property in the given list of property groups.
     * 
     * @param params the list of parameters.
     * @param propertyGroups the list of property groups.
     */
    private void addParamsForPropertyGroups(JSONArray params, List<PropertyGroup> propertyGroups) {
        for (PropertyGroup propertyGroup : propertyGroups) {
            addParamsForProperties(params, propertyGroup.getProperties());
        }
    }

    /**
     * Adds a parameter for each property in the given list of properties.
     * 
     * @param params the list of parameters.
     * @param properties the list of properties.
     */
    private void addParamsForProperties(JSONArray params, List<Property> properties) {
        for (Property property : properties) {
            JSON json = formatParamForProperty(property);
            if (json != null) {
                if (json.isArray()) {
                    JSONArray paramArray = (JSONArray)json;
                    for (int i = 0; i < paramArray.size(); i++) {
                        addParamForProperties(params, paramArray.getJSONObject(i));
                    }
                } else {
                    addParamForProperties(params, (JSONObject)json);
                }
            }
        }
    }

    /**
     * Adds the given param to the given params array if the param has an order of 0 or more.
     * 
     * @param params the array of parameters being built.
     * @param param the parameter to add to the array.
     */
    private void addParamForProperties(JSONArray params, JSONObject param) {
        if (param != null && param.optInt("order", -1) >= 0) {
            params.add(param);
        }
    }

    /**
     * Formats a parameter for the given property.
     * 
     * @param property the property.
     * @return the formatted parameter.
     */
    private JSON formatParamForProperty(Property property) {
        PropertyFormatter propertyFormatter = PropertyFormatterFactory.getFormatter(experiment.getJSONObject("config"),
            step, property, propertyValues);
        return propertyFormatter.formatProperty();
    }

    /**
     * Formats the deployed component with the given identifier.
     * 
     * @param componentId the deployed component identifier.
     * @return the formatted deployed component.
     */
    private JSONObject formatComponent(String componentId) {
        return new DeployedComponentFormatter(daoFactory).formatComponent(componentId);
    }

    /**
     * Gets the template associated with the given step if there is one associated with the given step.
     * 
     * @param step the step to find the template for.
     * @return the template.
     */
    private Template getTemplateForStep(TransformationStep step) {
        Template template = null;
        Transformation transformation = step.getTransformation();
        if (transformation != null) {
            String templateId = transformation.getTemplate_id();
            template = daoFactory.getTemplateDao().findById(templateId);
            if (template == null) {
                throw new WorkflowException("template " + templateId + " not found");
            }
        }
        return template;
    }

    /**
     * Formats the outputs for the job step.  The Foundational API takes care of input file staging and output file
     * retention, but the JEX still needs to know whether or not log files should be retained for debugging purposes.
     * 
     * @return the output parameters.
     */
    private JSONArray formatOutputs() {
        JSONArray outputs = new JSONArray();
        outputs.add(formatLogOutput());
        return outputs;
    }

    /**
     * Formats the output output definition for the logs directory.  This element is used to tell the JEX whether
     * or not the log files should be retained, which should only happen when debugging is enabled.
     * 
     * @return the JSON object representing the output definition.
     */
    private JSONObject formatLogOutput() {
        JSONObject out = new JSONObject();
        out.put("name", "logs");
        out.put("property", "logs");
        out.put("type", "File");
        out.put("multiplicity", "collection");
        out.put("retain", true);
        return out;
    }
}
